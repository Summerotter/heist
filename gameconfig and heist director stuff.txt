class GameConfiguration:
    def __init__(self):
        self.heist_count = 3
        self.scene_min = 3
        self.scene_max = 5
        self.scene_min_time_roll = 2
        self.scene_max_time_roll = 8
        self.scene_time_mod_per_scene = 2
        
        #would be able to edit this later via config options
        #expand this for Difficulty options later?
        #things like Black Market and Company Store stock/qty, basic_living_costs, bank fee, job wage.

game_config = GameConfiguration()
        
class Scene:
    def __init__(self,type,scene_id,heist_data):
        '''self.scene_id'''
        '''self.scene_data = scene_data_storage[scene_id]'''
        '''self.options = {}'''
        '''self.options['s'] = self.scene.option_dict['shoot'][randint(0,len(self.scene.option_dict['shoot'])-1)]'''
        '''self.options['s']['difficulty'] += heist_data.difficulty''' 
        
        '''if there are requirements for option, check them here. Discard if not meeting requirements'''
        '''Requirements can be skill or stat thresholds, or items in inventory'''
        '''might drop those out for now. Rewrite character stats to be a dict for ease of access?'''
        '''like, if requires_item elif requires_stat, can check directly by character.stats[requirement] >= Threshold '''
        
        '''check inventory for items that trigger options, adds here. Grenades, flashbangs''' 
        '''Format strings for self.scene_data for flavoring and foe.'''
        '''Format strings for self.options[all] for flavoring, foe, and final difficulty'''
        '''self.choice_list = {} / for option in self.options: self.choice_list[len(self.choice_list)]= (option, self.options['blurb'])'''
        
    def print_menu():
        '''prints option strings and option_choice_list for them'''
        '''for choice in self.choice_list: / print(choice,choice_list[choice][2])'''
        '''the above would be formatted nicer, yeah.
        
    def menu():
        print(self.scene_data['start_blurb'])
        run_menu = True
        print()
        while run_menu:
            self.print_menu()
            choice = input("Make your decision")
            '''format choice so it matches properly'''
            if choice in self.choice_list:
                results = test(self.options[choice])
                if results['pass']:
                    print(self.scene_data['success_blurb']
                    run_menu = False
                    director.results[self.scene_id] = results
                    #should collapse back to director control
                else:
                    print(self.scene_data['fail_blurb']
                    run_menu = False
                    director.results[self.scene_id] = results
                    #should collapse back to director control
            else:
                print("That isn't an option here!")
        
    def test(option_data):
        '''unpack option data'''
        results = {}
        if option_stat + randint(1,10) - character.total_penalties + character.total_mods >= randint(1,5) + total_difficulty:
            results['pass'] = True
            results['reward'] = grant_reward(data)
            '''stat or item adjustsments made as per option_success_cost, added to results dict'''
        else:
            results['pass'] = False
            '''stat or item adjustsments made as per option_success_cost, added to results dict'''
        return results
            
        
    def grant_reward(data):
        '''grabs reward per data'''
        '''satchet system or table rolls, see below'''
        '''returns result as tupple'''
        return (loot, cash, item)
        #note: Above defaults to None if None
        
scene_data_storage(itself stored by type)
-scene_id
-start_blurb
-success_blurb
-end_blurb
-option_dict{'stat/skill/item': [key_option_1, key_option_2,],}

option_data_storage
-option_id
-option_skill/stat
-option_item None or ItemName
-option_blurb
-option_difficulty
-option_success_blurb
-option_success_cost ((stat_key,-int,False),) #may have multiples. If True, is an item.
-option_fail_blurb
-option_fail_cost ((stat_key,-int,False),) #may have multiples. If True, is an item. 

Reward Options: Satchet System or Loot Table

satchet_system
-if satchet has none of one item, it has None in that place.
satchets = {
    'type_key': {
        'heist_difficulty' : { 
            'total_xp_phase': [(loot, cash, item,), satchet 2, satchet 2], 
            }, 
        }, 
    }
    
loot table
static table each for loot, cash, and items.
roll is dice+difficulty+(difficulty-character.xp_stage)
dice, bonus from how hard it was flat, penalty for easy heists or bonus for hard heists based on level range.

-HeistDirector generates a list of heists (Type, blurb, difficulty, scene_count)
-Player chooses one, it chooses scenes from scene_data_storage, adds them to self.scene_list[key1,key2,key3]
-self.results = {}, director.results[scene_id] = results that gets passed to it from Scene.menu().

class Director:
    def __init__(self):
        self.results = {}
        self.scene_list = []
        self.heist_options = {}
        self.run_menu = True
        
    def generate_heist_options(self):
        self.heist_options = {}
        #clears any prior heists.
        for heist in range(game_config.heist_count):
            self.heist_options[len(self.heist_options)+1] = self.heist_generator()
            #first would be heist_options[1], etc.
            
    def heist_generator(self):
    
        heist_difficulty = character.xp_stage + randint(-2,2)
        if heist_difficulty => 4:
            heist_difficulty = 4
            scene_count = game_config.scene_max
        elif heist_difficulty <= 0:
            heist_difficulty = 0
            scene_count = game.config.scene_min
        else:
            scene_count = randint(game_config.scene_min,game_config.scene_max)
            
        type = heist_types[randint(0,len(heist_types)-1)]
        heist_blurb_id = randint(0,len(heist_blurbs[type])-1)
        heist_foe = foes[type][randint(0,len(foes[type])-1)]
        
        scene_list = []
        for scene in scene_count:
            scene_master_list = list(scene_data_storage[type].keys())
            scene_list.append(scene_master_list[randint(0,len(scene_master_list)-1)])
               
        
        hours_cost = randint(game_config.scene_min_time_roll,game_config.scene_max_time_roll)+(game_config.scene_time_mod_per_scene*scene_count) 
        #defaults to 2-8 + 2 per scene, min 5, max 18.
        #variable. Needs work. Uses configs. Subtracts total from time_available when  heist ends
        heist  = {}
        heist['type']=type
        ...and so forth....
        ##format strings for heist blurb and option before passing it on
        return heist
        
            
    def run_heist(self, heist):
        self.results = {}
        #clearing prior heists
        self.scene_list = heist['scenes']
        for key in self.scene_list:
            scene = Scene(key,data)
            scene.menu()
        '''results and tally'''
        self.run_menu = False
        city.available_time -= heist['hours_cost']
        if city.available_time == 0:
            hideout.end_day()
        elif city.available_time < 0:
            hideout.end_day_penalty()
            ##you've got 20 hours in the day available; if you do anything in the morning and then heist you'll be back the next day instead.
            ##do not gain any health or stamina regen when this occurs.
        else:
            hideout.menu()
            
    def print_menu(self):
        '''Lists Heist options and back to Hideout'''
    
    def menu(self):
        '''self.run_menu = True'''
        '''print planner blurb from hideout'''
        '''print_menu()'''
        '''while self.run_menu:'''
        '''if choice == run_a_heist'''
        '''tab--self.run_heist(heist)'''
        #run_heist will directly back to the hideout.
        